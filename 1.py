# -*- coding: utf-8 -*-
"""1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-7T7Kyu4LPsiTlCSfdSPyeRZGyAY3TOC
"""

import networkx as nx
import random
import matplotlib.pyplot as plt

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import linregress
import random

def load_graph(file_path):
    ext = file_path.split('.')[-1].lower()
    if ext == 'gml':
        return nx.read_gml(file_path)
    elif ext == 'csv':
        return nx.read_edgelist(file_path, delimiter=',', nodetype=int, create_using=nx.Graph())
    elif ext == 'txt':
        return nx.read_edgelist(file_path, nodetype=int, create_using=nx.Graph())
    else:
        raise ValueError("Unsupported file format. Use txt, csv, or gml.")

def compute_properties(G, graph_type):
    degree_list = []
    for n, d in G.degree():
        degree_list.append(d)
    degrees = np.array(degree_list)

    avg_degree = np.mean(degrees)
    if nx.is_connected(G):
        avg_path = nx.average_shortest_path_length(G)
    else:
        avg_path = float('inf')
        print(f"{graph_type} graph is not connected.")
    clustering = nx.average_clustering(G)
    avg_k2 = np.mean(degrees ** 2)
    kappa = avg_k2 / avg_degree - 1 if avg_degree > 0 else 0
    critical_threshold = 1 / kappa if kappa > 0 else 0

    print(f"{graph_type} - Average Degree: {avg_degree}")
    print(f"{graph_type} - Average Path Length: {avg_path}")
    print(f"{graph_type} - Clustering Coefficient: {clustering}")
    print(f"{graph_type} - Critical Threshold (percolation p_c): {critical_threshold}")

    # Degree distribution plot (log-log)
    unique, counts = np.unique(degrees, return_counts=True)
    p_k = counts / float(len(degrees))
    plt.figure()
    plt.plot(unique, p_k, 'o', label='Data')
    plt.xscale('log')
    plt.yscale('log')
    plt.title(f'Degree Distribution ({graph_type})')
    plt.xlabel('Degree k')
    plt.ylabel('P(k)')
    plt.legend()
    plt.show()

    # For scale-free: check power-law fit and find exponent
    if graph_type == 'Scale-Free':
        mask = (unique >= 2) & (p_k > 0)
        if np.sum(mask) > 1:
            log_k = np.log(unique[mask])
            log_p = np.log(p_k[mask])
            result = linregress(log_k, log_p)
            gamma = -result.slope
            r2 = result.rvalue ** 2
            print(f"{graph_type} - Power-law exponent gamma: {gamma}")
            print(f"{graph_type} - R^2 for power-law fit: {r2}")
            if r2 > 0.9:
                print(f"{graph_type} - Fits power-law distribution well.")
            else:
                print(f"{graph_type} - Does not fit power-law distribution well.")
        else:
            print(f"{graph_type} - Insufficient data for power-law fit.")

    # Check path length between 2 random nodes
    nodes = list(G.nodes)
    u = random.choice(nodes)
    v = random.choice(nodes)
    while u == v:
        v = random.choice(nodes)
    if nx.has_path(G, u, v):
        dist = nx.shortest_path_length(G, u, v)
        print(f"{graph_type} - Distance between random nodes {u} and {v}: {dist}")
        if dist < 6:
            print(f"{graph_type} - Path length < 6 degrees of separation.")
        else:
            print(f"{graph_type} - Path length >= 6 degrees of separation.")
    else:
        print(f"{graph_type} - No path between random nodes {u} and {v}.")

try:
    print("FROM GML reading")
    G_loaded = load_graph('/content/network.gml')
    print("Loaded Graph from File")
    compute_properties(G_loaded, 'Loaded')
except FileNotFoundError:
    print("File not found. Please update the file path to your GML file.")
except Exception as e:
    print(f"An error occurred: {e}")

def generate_powerlaw_configuration(n, gamma, ensure_simple=True):
    seq = nx.utils.powerlaw_sequence(n, gamma)
    seq = [max(1, int(round(x))) for x in seq]
    if sum(seq) % 2 == 1:
        seq[np.random.randint(0, n)] += 1
    G_multi = nx.configuration_model(seq, create_using=None)
    if ensure_simple:
        G = nx.Graph(G_multi)  # removes parallel edges, keeps self-loops as edges (we remove them)
        G.remove_edges_from(nx.selfloop_edges(G))
        return G
    else:
        return G_multi

# Generate and analyze the 3 model graphs
n = 1000  # Number of nodes

# Random (Erdos-Renyi) graph, target avg degree ~10
avg_k = 4 # target average degree
p = avg_k / (n - 1)  # for ER
G_er = nx.erdos_renyi_graph(n, p)
print("\nRandom Graph")
compute_properties(G_er, 'Random')

# Scale-Free (Barabasi-Albert) graph, target avg degree ~10
m_ba = 5  # m=5 gives avg degree ~10
G_ba = nx.barabasi_albert_graph(n, m_ba)
print("\nScale-Free Graph")
compute_properties(G_ba, 'Scale-Free')

# Watts-Strogatz graph, target avg degree 10
k_ws = 10
p_ws = 0.1  # Rewiring probability
G_ws = nx.watts_strogatz_graph(n, k_ws, p_ws)
print("\nWatts-Strogatz Graph")
compute_properties(G_ws, 'Watts-Strogatz')

G_pow=generate_powerlaw_configuration(n, gamma=2.1, ensure_simple=True)
compute_properties(G_pow,'Power law dist')