# -*- coding: utf-8 -*-
"""5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-7T7Kyu4LPsiTlCSfdSPyeRZGyAY3TOC
"""

import networkx as nx
import random
import matplotlib.pyplot as plt
import collections

# -*- coding: utf-8 -*-
"""fromgiven.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EgnzqN8Em2TIlcLCabfjM_7mIhG4wqiU
"""

# --- Step 3: Measure Key Properties of Your Graph ---
G_real=nx.read_gml("network.gml")
N = G_real.number_of_nodes()
L = G_real.number_of_edges()
avg_degree = (2 * L) / N
avg_clustering = nx.average_clustering(G_real)

print(f"\n--- Real Graph Properties ---")
print(f"Nodes (N): {N}")
print(f"Edges (L): {L}")
print(f"Average Degree <k>: {avg_degree:.4f}")
print(f"Average Clustering Coefficient C: {avg_clustering:.4f}")

# --- Step 4: Estimate Parameters for Each Model ---
print("\n--- Estimating Model Parameters ---")

# ER Parameters
N_er = N
p_er = avg_degree / (N - 1)
print(f"Erdős-Rényi: N={N_er}, p={p_er:.4f}")

# WS Parameters
N_ws = N
k_ws = round(avg_degree)
if k_ws % 2 != 0: k_ws += 1 # k must be even
print(f"Watts-Strogatz: N={N_ws}, k={k_ws}, p=(requires fitting)")

# SF/BA Parameters
N_sf = N
m_sf = round(avg_degree / 2)
print(f"Scale-Free (BA): N={N_sf}, m={m_sf}")

# --- Step 5: Plot the Real Degree Distribution to Check for Best Fit ---
degree_sequence = sorted([d for n, d in G_real.degree()], reverse=True)
degree_count = collections.Counter(degree_sequence)
deg, cnt = zip(*degree_count.items())

plt.figure(figsize=(8, 6))
plt.loglog(deg, cnt, 'o', color='navy')
plt.title("Degree Distribution of Data from CSV (Log-Log Scale)")
plt.xlabel("Degree (k)")
plt.ylabel("Count P(k)")
plt.grid(True)
plt.show()

import numpy as np
import collections
from scipy import stats

def plot_distribution_fits(G, ax):
    degrees = [G.degree(n) for n in G.nodes()]
    avg_degree = np.mean(degrees)
    num_nodes = G.number_of_nodes()

    degree_counts = collections.Counter(degrees)
    deg, cnt = zip(*degree_counts.items())
    sorted_pairs = sorted(zip(deg, cnt))
    deg, cnt = [list(t) for t in zip(*sorted_pairs)]

    ax.loglog(deg, cnt, 'o', color='b', label='Actual Distribution')
    ax.axvline(avg_degree, color='r', linestyle='--', linewidth=2, label=f'Avg. Degree: {avg_degree:.2f}')

    # --- Power-law fit ---
    log_deg = np.log10(deg)
    log_cnt = np.log10(cnt)
    valid_indices = np.isfinite(log_deg) & np.isfinite(log_cnt)

    if len(log_deg[valid_indices]) > 1:
        slope, intercept, _, _, _ = stats.linregress(log_deg[valid_indices], log_cnt[valid_indices])
        gamma = -slope
        power_law_fit = (10**intercept) * (np.array(deg)**slope)
        ax.loglog(deg, power_law_fit, '--', color='g', label=f'Power-Law Fit (γ ≈ {gamma:.2f})')

    # --- Exponential fit ---
    exp_lambda = 1.0 / avg_degree
    exponential_fit = num_nodes * exp_lambda * np.exp(-exp_lambda * np.array(deg))
    ax.loglog(deg, exponential_fit, '--', color='orange', label='Exponential Fit')

    ax.set_title("Degree Distribution with Fits (Log-Log)")
    ax.set_xlabel("Degree (k) - Log Scale")
    ax.set_ylabel("Count - Log Scale")
    ax.legend()

import networkx as nx
import matplotlib.pyplot as plt

# 1. Create a graph (e.g., Scale-Free)
N = 100
m = 2
G = nx.barabasi_albert_graph(N, m, seed=42)

# 2. Create a figure and axes
fig, ax = plt.subplots(figsize=(8,6))

# 3. Call your function
plot_distribution_fits(G, ax)

# 4. Show the plot
plt.show()

